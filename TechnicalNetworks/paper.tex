% This will be the main document for the Technical Networks paper to
% be written by the Eggnet team of Jordan Ell, Triet Huynh and Braden
% Simpson in association with Adrian Schroeter and Daniela Damian.

\documentclass[conference]{IEEEtran}

% Use of outside images
\usepackage{graphicx} 
% Use text inside euqations
\usepackage{amsmath}

% Correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% Begin the paper here
\begin{document}


% Paper title
% Can use linebreaks \\ within to get better formatting as desired
\title{Finding Harmful Structures Among Developer Networks}

% Authors names
\author{\IEEEauthorblockN{Jordan Ell}
\IEEEauthorblockA{University of Victoria,
Victoria, British Columbia \\ jell@uvic.ca}
}

% Make the title area
\maketitle


\begin{abstract}
Software systems have not only become larger over time, but the amount of
technical contributors and dependencies have also increased. With these expansions also comes
the increasing risk of introducing a software failure into a pre-existing system.
Software failures are a multi-billion dollar problem in the industry today and while integration and
other forms of testing are helping to ensure a minimal number of failures, research to understand
full impacts of code changes and their social implications is still a major concern. This paper describes
how analysis of code changes and the technical relationships they infer can be used to detect pairs
of developers whose technical dependencies may induce software failures. These developer pairs may
also be used to predict future software failures as well as provide recommendations to contributors
to solve these failures inside of source code changes.
\end{abstract}


\section{Introduction}

% Setup the problem.
Large software projects are created using highly modular and 
reusable code. This creates technical dependencies between methods or functions
that can be used in a wide variety of locations throughout the project. 
This causes changes to any given method to have a rippling 
effect across the rest of the project~\cite{Acharya:2011:PCI}. The larger these effects are,
the more likely they are to cause a software failure inside the system during the project's
life span~\cite{Zimmermann:2008:PDU}. These observations of technical dependencies open
the door to types of analysis on the developer networks they infer and preventing software
failures.

% Explain technical network research that already exists
Technical dependencies in a project can be used to predict success or failure of 
code changes or builds~\cite{Pinzger:2008:DNP, Zimmermann:2008:PDU}. However, most 
research in this area is based off of identifying
central modules inside a large code base which are likely to cause software failures or
detecting frequently changed code that can be associated with previous failures
~\cite{Kim:2006:AIB}. 
This module method also results in predictions 
at the file or binary level of software development as opposed to a changeset level
and often lack the ability to provide recommendations other than test focus.

% Research question
With the power of technical dependencies in predicting software failures , the question is posed: 
"\textit{Is it possible to locate pairs of developers whose technical dependencies in code changes
statistically relate to bugs?}"

% Explain our brief intended approach
This paper explains the approach used to locate these pairs of developers among developer networks.
The process utilizes code changes and the call hierarchies effected  to find patterns of contributor 
relationships in successful and failed code changes.  We can use these contributor relationships 
to also promote the idea of socio-technical congruence with coordination recommendations.

% Technical network figure
\begin{figure*}[tb!]
\centering
\includegraphics[width=0.9\textwidth]{images/TecNetwork}
\caption{A technical network for a changeset. Cody has changed method getX() which is being
called by Bart's method foo() as well as Daisy and Adam's method bar().\label{fig:network}}
\end{figure*}

\section{Methodology}

\subsection{Extracting Technical Networks}
% End goal
The goal, is to create a technical network of contributors based on method ownership
and those method's call hierarchies effected by code changes. These networks will provide
dependency edges between contributors caused by code changes which may be 
identified as possible harmful pairings. (Figure~\ref{fig:network}). To achieve this goal,
we must identify developer owners of methods, method call hierarchies (our technical
dependencies) and code change effects on these hierarchies.

% Owners
To determine which contributors own which methods at a given code change,
the Git repository was queried. Git stores contributors of a file per line, which was used to extrapolate
a percentage of ownership given a method inside the file.

% Call Graph
To extract method call hierarchies in a project at a given code change,
a method call graph was constructed. Unlike other approaches such as Bodden's et al.~\cite{Bodden:2003:HVJ} 
of using byte code and whole projects, call graphs were built directly from source code files
inside of a code change, 
which does not have the assumptions of being able to compile or have access to all project 
files. It was important to not require project compilation at each code change because it is
an expensive operation as well as the code change effects may cause the project
to be unable to compile. Using source files also allowed an update to the call graph
with changed files as opposed to completely rebuilding at 
every code change. This created a rolling call graph which 
can be used to show method hierarchy at each code change inside a project opposed to
a static project view.

% Changeset effects
The code change effect, if any, to the call hierarchy was then found. The Git
software repository was used to determine what changes were made to any give file inside a 
code change. Specifically, methods modified by a code change were searched for. The call graph 
was then used to determine which methods call those that have been changed, which
gives the code change technical dependencies.

%Resulting network
These procedures, resulted in a technical network based on contributor method ownership 
inside a call hierarchy effected by a code change (Figure~\ref{fig:network} left hand side).
The network was simplified by only using edges between developers since we 
are only interested in discovering the problematic edges between developers and not the 
methods themselves (Figure~\ref{fig:network} right hand side). This is the final technical 
network.

\subsection{Identifying Harmful Structures}
To identify harmful structures (edges) inside technical networks, we analyze 
edges in relation to discovered changeset failures. To determine whether a changeset 
was a success or failure (introduce a software failure), we use the approach of
Sliwerski et al.~\cite{Sliwerski:2005:CIF}. We then proceed in the following steps:

\begin{enumerate}
\item Identify all possible edges from the technical networks.
\item For each edge, count occurrences in technical networks of failed changesets.
\item For each edge, count occurrences in technical networks of successful changesets.
\item Determine if the edge is related to success or failure.
\end{enumerate}

To determine an edge's relation to success or failure, we create the value FI (failure
index) which represents the normalized chance of a changeset failure in the presence
of the edge. 

\begin{equation}
\text{FI} = \frac{ \text{edge}_{failed} / \text{total}_{failed}}{\text{edge}_{failed} / \text{total}_{failed} + \text{edge}_{success} / \text{total}_{success}}
\end{equation}

Contributor pairs with the highest FI value are said to be harmful structures
inside a project. We store these edges in Table~\ref{tab:ratio}. We also perform
a Fisher Exact Value test on edge appearance in successful and failed
changesets, and non-appearance in successful and failed changesets to only
consider statistically significant edges. 


\section{Results}
For this paper, we choose to study the Hibernate-ORM project which is an open source Java 
application hosted on GitHub\footnote{https://github.com/}. The issue tracking for this 
project is performed by Jira\footnote{http://www.atlassian.com/software/jira/overview}.

We chose this project because our tool only handles Java code and it is written in Java 
for all internal structures and control flow
and uses Git for version control. Hibernate-ORM also uses issue tracking software which 
is needed for determining changeset success or failure~\cite{Sliwerski:2005:CIF}.

In Hibernate-ORM, we found a total of X contributor pairs existed over the entire project, 
of which Y were found to be harmful inside of the system (A FI value of G or higher). 
We rank the pairings by their respective FI values(Table~\ref{tab:ratio}).

\begin{table}[h]
\begin{center}
\begin{tabular}{@{\hspace{.2cm}}ccc@{\hspace{.75cm}}c@{\hspace{.2cm}}c@{\hspace{.2cm}}}
\hline
Pair & Successful & Failed & FI & P-Value\\
\hline
(Daisy, Adam)	&	0&	14&	1.0000& 0.0001249		\\
(Cody, Bart)	&	1&	12&	0.9190& 0.003468	\\
(Emma, Fred)	&	1&	9&	0.8948& 0.02165      \\
\hline
\end{tabular}
\end{center}
\caption{The top 3 harmful contributor pairs found and ordered by FI.\label{tab:ratio}}
\end{table}

By recognizing known harmful pairings in new changeset networks, we can also predict that a
given changeset will fail based on these pairings FI value. We were able to predict 
W out of Z failures from a sample size of T  given changesets inside of Hibernate-ORM 
with Q false positives. More importantly, given 
the known harmful pairing, we can recommend communication between the two 
contributors.


\section{Conclusion and Future Work}
Technical dependencies are often used to predict software failures
in large software system~\cite{Pinzger:2008:DNP, Zimmermann:2008:PDU, Kim:2006:AIB}. 
We have found evidence that technical dependencies predict failures based on contributor
dependencies found in changesets. Through the contributor dependencies,
we can also give recommendations to contributors about whom to contact to
resolve potential issues.

In future work, we will add communication networks on a per commit basis as well. We plan
to investigate the congruence of these social and technical networks and its effects on 
software quality.



\bibliographystyle{IEEEtran}
\bibliography{paper}


% End of the paper
\end{document}
